{"name":"androidNDKStudy","tagline":"A study re: how to make Android Studio, the experimental Gradle plugin, the NDK, JNI, a mixture of Java, C, and C++, and the debugger all play nice and do tricks. ","body":"#Getting Started with Android Studio, JNI, and the NDK.\r\n_and_\r\n\r\n##How to debug C++ with Android Studio.\r\n\r\n##Introduction\r\nThe purpose of my quest is to generally figure out how to work with Android Studio, JNI, and the NDK.  Getting going with samples was the easy part.  Unfortunately, getting a graphical debugger for C++ figured out was totally the Devil's work.  There are a lot of people screaming for answers on the Internet but the solution proved to be remarkably elusive.  This is the tale of my quest.\r\n\r\n##Good News! It's ALIVE!\r\n\"Cut the crap Tom\" you say?  \"Just tell me how it works!\"  Ok, here we go...\r\n\r\n* The overall process of building an Android app, using native code presently works fairly well.  For example, in my experience, Android Studio 1.3.2, the NDK r10e, and the experimental Gradle plugin all play nicely together, whether on Ubuntu 15.04, 64bit, or lowly WinXP. RTFM and you're quickly good to go.\r\n\r\n* The thousand things I tried before I figured this out shall not be agonized upon here.  See supra for my tales of woe.\r\n\r\n* The specific configuration that I have, that I can use to successfully set and stop at C++ breakpoints is Ubuntu 15.04, 64bit, Android Studio 1.3.2, NDK r10e, and a Nexus 6 emulator, x86, API 23.\r\n\r\n* You'll need to define a run-configuration of type \"Android Native.\" The configuration is very simple and self-explanatory.  Accept the defaults, but be sure to set a module. Please notice the \"native debugger\" tab and that LLDB is the default.  I never could get this to work with GDB, but I don't care because LLDB is better.\r\n\r\n* You'll still need to define run-configuration for ordinary Java debugging.  In fact, you can only execute one or the other, at any time.  That is, do Java-only debugging, or C++-only debugging, but not both at the same time.\r\n\r\n* Unlike the ordinary \"run\" vs. \"debug\" distinction for other run-configuration, run and debug, for Android Native configurations, appear to do exactly the same thing.  So just running the configuration is sufficient to wake up the debugger.\r\n\r\n* When we run the configuration, after we select a suitable device, look for the \"console\" tab in the DebugNDK pane.  It may by default pop to the front, but if not, look for it.  The magic words you want to see are:\r\n\r\n\"Now Launching Native Debug Session.\"\r\n\r\nThen after some modest delay, if all goes well, immediately after the above you'll see...\r\n\r\n* \"Debugger attached to process nnnn.\"\r\n\r\nThe first time I did this it took a minute or two for the debugger to attach.  Subsequently it does so in a handful of seconds.\r\n\r\nWipe the sweat from your brow, you're getting real close to success!\r\n\r\n* When you execute the run-configuration, it's off to the races.  The application will just start going.  Meanwhile the debugger is taking its time connecting.  If execution passes any of your break points before the debugger is ready, then guess what happens?  That's right, the debugger won't stop on any of those breakpoints.\r\n\r\nSo therefore...\r\n\r\n* You'll need to introduce some means of delay, such as sleep or a Button to click and trigger JNI action, so that the debugger will have time to connect _before_ execution reaches your break points.\r\n\r\n* Be especially careful in this when dealing with System.loadLibrary.  This is frequently done as a static initializer in a class, but can be done anywhere, such as inside your Button's onClick handler.\r\n\r\n\r\n##Why is this hard?\r\n\r\nConnecting a debugger to the native code on an Android device was a very difficult thing to do.\r\nThere are a myriad of random approaches to be found on the Internet, most of which are outdated.  None of them have worked for me. Why was this hard to do?\r\n\r\nMaybe I'm just an idiot.  That would explain a lot.  But something to realize about this puzzle is that there's some complexity afoot that\r\ndefies the lazy-man's find-some-recipes-on-the-Internet approach.  Although said method frequently \"works\" with lesser goals, it has failed me here. So, failing that, I've had to instead study the problem in greater depth.\r\n\r\nThe overall puzzle is composed of two related parts:\r\n\r\n* We need to build something that goes onto an Android device.\r\n\r\n* We need a debugger on a development machine to communicate with the executing code on the device.\r\n\r\nA second and a half issue is that I for one would really like an easy-to-use graphical debugger.\r\n\r\nSand is injected into the machinery of this process in that:\r\n\r\n* There are at least three operating systems plausibly involved if you only count Android, Linux, and Windows. And there's plenty more confusion if you peer more closely at the various variations of each and their barefoot kinfolk such as Wine or Cygwin.\r\n\r\n* You'll want the Android SDK and NDK.\r\n\r\n* There are at least two main programming languages involved, Java and C++.  And more if you want to count C, shell scripting, Python, and Groovy.\r\n\r\n* There are multiple build processes potentially at work.  Such as Gradle and Ant, to build the .apk and ndk-build and make to build the C++ binaries.\r\n\r\n* The build tools use lower level tool chains.\r\n\r\n* There are at least two IDE's that are commonly used to invoke these build processes, Android\r\nStudio and Eclipse. Three if you want to count Visual Studio.  You can also do this via command\r\nline.\r\n\r\n* All of the above can be found in many different versions, if you only count the public \r\nreleases. Heaven help whoever gets their hands on some source code with the myriad of additional\r\nversions thus available.\r\n\r\n* The debuggery only works with certain blessed combinations of versions and the actual\r\nfunctionality of all of the above changes significantly and rapidly.  This causes us to lose focus on the big picture and become mired in tedious little details.\r\n\r\n* Nothing you find on the Internet is going to _exactly_ match your particular circumstances. If\r\nnot, is it close enough? Will you be able to adapt? Good luck with that!\r\n\r\nSo if you just got lucky and some permutation of the above works for you, congratulations! For the\r\nrest of you, read on...\r\n\r\n##Digging deeper\r\n\r\n###Development machine OS\r\n\r\nYou will need to pick an OS to use on your development machine. For purposes of example I'm using\r\n64-bit Ubuntu 15.04 and the lowly Windows XP (which is always 32 bit.)\r\n\r\n###Install the Android SDK\r\n[Understanding the Android SDK](AndroidSDK.md)\r\n\r\n###Install the Android NDK\r\nI have NDK r10e on the Windows XP machines and r8e on Ubuntu.\r\n\r\n###Eclipse\r\nStart with Eclipse, the CDT, the ADT, Linux, and gdb.  At the time of writing, the NDK documentation\r\nand samples all assume these things, so this is the easiest path to get started.  I'm using Eclipse\r\nMars on the Ubuntu machine.\r\n\r\nAndroid Studio and the experimental Gradle plugin allegedly can do this. And it does, if you don't\r\nmind omitting debuggin.  But I have been unable to find examples, documentation, or sufficient\r\ngood-luck to stumble upon the answer.  There's a ferocious snake nest of complexity in this and\r\nbefore we jump to that level, I think it's wise to start with the basics.\r\n\r\nUnfortunately, Eclipse is, IMHO, not aging gracefully.  I've been able to get the above combo\r\nto stop on breakpoints in C, C++, and JNI_OnLoad (a previously elusive target) using the graphical\r\ndebugger.  But getting there involved dealing with a mountain mysterious problems, of which many\r\nare merely in remission even now.\r\n\r\nThe Eclipse build process builds the Android app as usual. In doing so it incorporates some files\r\ncreated by the NDK.  It also invokes NDK_BUILD and builds the C++ bits.\r\n\r\nSome documentation suggests that you invoke ndk-build from the command-line whenever you see fit\r\nand then rebuild the Android app.  My experience has been that this is unnecessary because Eclipse\r\ndoes that already.  My experience has also been the Eclipse build is haunted.  Sometimes it seems\r\nto build and sometimes not.\r\n\r\nRealize that ndk-build is a shell script.  If you examine the source code, you'll find clues about\r\nwtf it's doing, and what it might do if properly coaxed via command line args.  This trick is\r\nespecially useful if the NDK tools are taunting you with mysterious error messages.\r\n\r\nndk-build NDK_LOG=1 will start up the build and emit lots of logging messages.\r\n\r\nMake sure to apply NDK Nature to the Eclipse project!\r\n\r\nThere is some issue with ordinary users not being able to use the USB ports and this throws\r\na monkey into the wrench re: using adb, which ndk-build uses.  Search for \"udev\" for more info.\r\n\r\n## How to get started with Android Studio, the Experimental Gradle plugin, the NDK, JNI, C, and C++\r\n\r\nThe vast majority of Android development is done using Java.  However, there are times when\r\nwe want to access native code from Java.  For example, maybe you have some C or C++ code\r\nthat you want to use.  Whether this is a good idea or not is a separate\r\nissue.  Assuming that you've c/o/n/s/u/l/t/e/d/ /y/o/u/r/ /8/-/b/a/l/l/ made your informed decision\r\nand have decided to do it, let me share some tips that I found useful.\r\n\r\nOverall, you'll be happy to know that doing this with Android Studio and Gradle is very feasible.\r\nAs of the time of writing (Aug 2015), this apparently is a recent development and all other\r\ndocumentation that I have found was for doing this with Eclipse, the command line, or doing various\r\ncontortions to make it work with Android Studio and Gradle.  Fortunately none of that's necessary.\r\n\r\nThe key to success in this endeavor, IMHO, is to figure out the [experimental Gradle plugin]\r\n(http://tools.android.com/tech-docs/new-build-system/gradle-experimental).\r\nYou'll need to also study the [Java Native Interface (JNI)]\r\n(http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) and the\r\n[Android Native Development Kit (NDK)](http://developer.android.com/ndk/guides/index.html).\r\nJNI is Java's spec for how Java should interact\r\nwith not-Java, and the NDK is the kit you need to connect Android/Java to JNI. \r\n\r\nThe NDK is easy and straight-forward to download and install and there are no hidden surprises here.\r\nStart with README.txt and nose around in /docs and see what you find. However, the docs and samples,\r\nas of ndk-r10e, are still for Eclipse and the ADT.  You can however import the samples into Android\r\n Studio and it will create suitable gradle.build files for you, using the experimental Gradle plugin.\r\n\r\nOne pleasant surprise is that the Gradle/NDK plugin is fairly good at figuring out what to do,\r\nby default, without a lot of hand-holding.  This illustrates the ole convention-over-configuration\r\nprinciple.  So Gradle/NDK is able to find our source files and headers and libraries\r\n and all that stuff, and figure out what to do with whatever outputs it creates,\r\n without me having to micro-manage. Just sit back and enjoy a /f/a/t/ cold one\r\n while [Skynet takes over](https://www.youtube.com/watch?v=_Wlsd9mljiU).  No more futzing with cranky software!\r\n\r\nUnfortunately, there are some nettlesome mysteries still lurking therein.\r\n\r\nThe biggest immediate problem that I found was that it's just not possible to debug the C/C++ code\r\nusing the experimental Gradle Plugin and Android Studio.  Although promised soon, it ain't here yet.\r\n\r\n##Tips from Tom!\r\n\r\nOne of the things that really bedeviled me in figuring this out was getting the naming\r\nright for C and C++ functions.  For example, if you declare native String foo, in Java class\r\nBar, you will need a suitably named function _somewhere_ in your collection of C/C++ source files.\r\nThe tedious rules for what exactly to name this include the Java package and class name of\r\nthe Java doing the calling.  This in and of itself is not so difficult.  The problem is if\r\nyou don't get this right, the exception messages are not helpful.  So the tip is...\r\n\r\nDeclare your native method first, in your Java source, and let the Android Studio tell you\r\nthat it can't find the expected function definition.  When doing so, AS will tell you\r\nspecifically what it's looking for!  (Note: This seems to be a sporadically available \"feature\"\r\nso YMMV.)\r\n\r\nAnother thing... By default, neither Android.mk nor Application.mk are used\r\nand thus we can just remove them. But there's a configuration option to let us use them\r\nif we like. Whatever they do, we can do with the experimental Gradle plugin.\r\n\r\nAnother things... Be sure to examine the extern \"C\" { JNIEXPORT ... JNICALL stuff in the\r\ncpp file.  We need it.  If it's not there, your Java cannot find the methods.\r\n\r\n\r\nFor this effort I'm using Android Studio 1.3.2, NDK r10e,\r\ncom.android.tools.build:gradle-experimental:0.2.0, on WinXP.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}